### 字面量字符和元字符
1. 字面量字符（literal characters）：某个字符只表示它字面的含义
2. 元字符（metacharacters）：除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思

##### （1）点字符 (`.`)     
匹配除回车（`\r`）、换行(`\n`) 、行分隔符（`\u2028`）和段分隔符（`\u2029`）以外的`所有字符`

##### （2）位置字符
-  `^` 表示字符串的`开始位置`
-  `$` 表示字符串的`结束位置`

```javascript
// test必须出现在开始位置
/^test/.test('test123') // true

// test必须出现在结束位置
/test$/.test('new test') // true

// 从开始位置到结束位置只有test
/^test$/.test('test') // true
/^test$/.test('test test') // false
```

##### （3）选择符（ `|` ）

表示“或关系”（OR），即cat|dog表示匹配cat或dog。

##### （4）转义符（ `\` ）

##### （5）特殊字符
正则表达式对一些不能打印的特殊字符，提供了表达方法
- `\cX` 表示Ctrl-[X]，其中的`X`是A-Z之中任一个英文字母，用来匹配控制字符。
- `[\b]` 匹配退格键(U+0008)，不要与`\b`混淆。
- `\n` 匹配换行键。
- `\r` 匹配回车键。
- `\t` 匹配制表符 tab（U+0009）。
- `\v` 匹配垂直制表符（U+000B）。
- `\f` 匹配换页符（U+000C）。
- `\0` 匹配null字符（U+0000）。
- `\xhh` 匹配一个以两位十六进制数（`\x00`-`\xFF`）表示的字符。
- `\uhhhh` 匹配一个以四位十六进制数（`\u0000`-`\uFFFF`）表示的 Unicode 字符。

##### （6）字符类
字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如`[xyz]` 表示`x`、`y`、`z`之中任选一个匹配。
- 脱字符（^）
    
    如果方括号内的第一个字符是`[^]`，则表示除了字符类之中的字符，其他字符都可以匹配。

    比如，`[^xyz]`表示除了`x`、`y`、`z`之外都可以匹配。
    
    `[^]` 表示匹配一切字符
    
    > 注：脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。
- 连字符（-）

    当连字号用在方括号之中，表示连续的字符序列
    
    `[abc]`可以写成`[a-c]`，`[0123456789]`可以写成`[0-9]`
    
##### （7）预定义模式
预定义模式指的是某些常见模式的简写方式。

- `\d` 匹配0-9之间的任一数字，相当于`[0-9]`。
- `\D` 匹配所有0-9以外的字符，相当于`[^0-9]`。
- `\w` 匹配任意的字母、数字和下划线，相当于`[A-Za-z0-9_]`。
- `\W` 除所有字母、数字和下划线以外的字符，相当于`[^A-Za-z0-9_]`。
- `\s` 匹配空格（包括换行符、制表符、空格符等），相等于`[ \t\r\n\v\f]`。
- `\S` 匹配非空格的字符，相当于`[^ \t\r\n\v\f]`。
- `\b` 匹配词的边界。
- `\B` 匹配非词边界，即在词的内部。

##### （8）重复类
模式的精确匹配次数
- `{n}` 表示恰好重复 `n` 次
- `{n, }` 表示至少重复 `n` 次
- `{n,m}` 表示重复不少于 `n` 次，不多于 `m` 次

##### （9）量词符
量词符用来设定某个模式出现的次数。
- `?` 问号表示某个模式出现`0次或1次`，等同于 `{0, 1}`
- `*` 问号表示某个模式出现`0次或多次`，等同于 `{0, }`
- `+` 加号表示某个模式出现`1次或多次`，等同于 `{1, }`

##### （10）贪婪模式
上一小节的三个量词符，默认情况下都是`最大可能匹配`，即`匹配直到下一个字符不满足匹配规则为止`。这被称为贪婪模式。
- 将贪婪模式改为非贪婪模式:在量词符后面加一个问号
    ```javascript
    var s = 'aaa';
    s.match(/a+?/) // ["a"]
    ```
    
##### （11）修饰符（modifier）
表示模式的附加规则，放在正则模式的最尾部



### 元字符详细解读
##### `()`
- 提高优先级
- 分组引用
    ```javascript
    //=> 分组引用： \1 \2 \N ...出现和第N个分组一模一样的内容
    var reg = /^([a-z])([a-z])\2([a-z])$/;
    reg.test('food'); //-> true
    reg.test('foot'); //-> true
    ```
    
- 分组捕获

##### `[]`
`[xyz][^xyz][a-z][^a-z]`

```javascript
//=> \w: 数字字母下划线中的任意一个字符
// ver reg = /^[a-zA-Z0-9_]$/; //=>等价于\w

//=> 中括号中出现的元字符，一般都代表本身的含义
// var reg = /^[.?+&]+$/; //=> 里面四个字符都是其本身的含义

//=> 需求：描述样式类名(数字、字母、下划线、-)，并且不能以-开头
// var reg = /^\w[\w-]*$/;
// var reg = /^[a-zA-Z0-9_][a-zA-Z0-9_-]*$/;
```

### 实例
##### 验证有效年龄
需求：验证18～65之间的年龄
```javascript
var reg = /^((1[89])|([2-5][0-9])|(6[0-5]))$/;
```

##### 验证有效数字
需求：验证是否为有效数字
- 可能是正数，可能是负数 12 -12
- 整数或者小数 0 12 0.2 
- 只要出现小数点，后面至少要跟一位数字
- 小数点前面必须有数字
```javascript
var reg = /^-?(\d|([1-9]\d*))(\.\d+)?$/;
/**
* -? 负号可有可无
* (\.\d+)? 小数部分可有可无，有的话点后面必须跟一位数字
* (\d|([1-9]\d*)) 整数部分
*       \d 一位数可以是任何数字
*       ([1-9]\d*) 多位数不能以零开头
*/      
```

##### 验证手机号码
需求：
- 11位数字
- 1开头

```javascript
var reg = /^1\d{10}$/;
```

##### 验证生身份证号码&分组捕获
需求：
- 18位
- 前17为必须是数字
- 最后一位可以是数字或者X(X代表数字10)
- 130828199012040617
    - 前六位 省市县
    - 接下来八位 出生年+月+日 19901204
    - 倒数第二位数字 奇数代表男 偶数代表女

```javascript
//月 ((0[1-9])|(1[0-2]))
//日 ((0[1-9])|([12][0-9])|(30|31))
var reg = /^((\d{6})(\d{4})(\d{2})(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|30|31)(\d)(\d|X))$/;
reg.exec('130828199012040617') //-> ["130828199012040617", "130828199012040617", "130828", "1990", "12", "04", "06", "1", "7", index: 0, input: "130828199012040617", groups: undefined]
```

### 正则捕获
把当前字符串中符合正则的字符串捕获到
- `RegExp.prototype`: `exec` 实现正则捕获的方法

当正则捕获的时候：
1. 先去验证当前字符串和正则是否匹配，如果不匹配返回的结果是null（没有捕获到任何到内容）
2. 如果匹配，从字符串最左边开始，向右查找到匹配到内容，并且把匹配到内容返回

exec捕获到结果到格式：
- 获取到结果是一个数组
- 数组中的第一项是当前本次大正则在字符串中匹配到到结果
- `index`：记录类当前本次捕获到结果的起始索引
- `input`：当前正则操作的原始字符串
- 如果当前正则中有分组，获取的数组中，从第二项开始都是每个小分组本次匹配到的结果（通过`exec`可以把分组中的内容捕获到）

- 执行一次`exec`只能把符合正则规则条件中的一个内容捕获到，如果还有其它符合规则的，需要再次执行`exec`才有可能捕获到

```javascript
var str = 'test2017type2018';
var reg = /\d+/;
reg.exec(str); //-> ["2017", index: 4, input: "test2017type2018", groups: undefined]
```

##### 正则捕获的懒惰性
执行一次exec捕获到第一个符合规则到内容，第二次执行`exec`，捕获到到依然是第一个匹配的内容，后面匹配的内容不管执行多少次`exec`都无法捕获到

解决正则捕获到懒惰性：
- 在正则到末尾加修饰符`g`（全局匹配）

正则为什么会存在懒惰性？
- 正则本身有一个属性：`lastIndex`(下一次正则在字符串中匹配查找到开始索引)
- 默认值：0，从字符串第一个字符开始查找匹配到内容
- 默认不管执行多少遍`exec`方法，正则到`lastIndex`值都不会变
- 当我们手动把`lastIndex`进行修改都时候，不会起作用

为什么加修饰符`g`就能解决懒惰性？
- 加了修饰符`g`，每次`exec`结束后，浏览器会默认把`lastIndex`值进行修改，下一次从上一次结束都位置开始查找，所以可以得到后面匹配都内容了

##### 批量捕获
exec有自己都局限性，执行一次exec只能捕获到一个和正则匹配的结果（即使加了修饰符g），如果需要都捕获到，我们需要执行N次exec方法才可以

```javascript
RegExp.prototype.myExecAll = function myExecAll() {
    let str = arguments[0] || '',
        result = [],
        ary = this.exec(str);
    if (!this.global) {return ary;} // 判断this是否加了全局修饰符G
    while (ary){ // ary !== null
        result.push(ary[0]);
        ary = this.exec(str);
    }
    return result;
}
let reg = /\d+/g;
reg.myExecAll('test2017type2018'); //=> ["2017", "2018"]
```




##### 使用test也可以实现正则捕获
不管是正则的匹配还是正则的捕获，在处理时候的原理是没区别的：**从字符串非第一个字符向后查找，找到符合正则规则的字符，如果可以找到，说明正则和字符串匹配（test检测返回true、exec捕获返回捕获的内容），如果找到末尾都没有匹配的，说明正则和字符串不匹配（test检测返回false、exec捕获返回null）**

**如果正则设置了修饰符`g`，不管使用`test`还是`exec`，都会修改`lastIndex`值**

```javascript
var reg = /\{(\d+)\}/g;
var str = 'my name is {0}~~';
if (reg.test(str)) {
    console.log(reg.lastIndex); //-> 14
    console.log(reg.exec(str)); //-> null
}
```

使用test实现正则捕获
```javascript
var reg = /\{(\d+)\}/g;
var str = 'my name is {0}~~';
var flag = reg.test(str);
console.log(RegExp.$1); //=> $1获取到当前本次匹配内容中第一个小分组的内容
```





  
  


### 所有支持正则的方法都可以实现正则捕获（一般都是字符串方法）
- match
- split
- replace
- ...

```javascript
let str = 'name=xhh&age=1';

let ary = str.split(/[=&]/); //-> ["name", "xhh", "age", "1"]
ary = str.split(/=|&/); //-> ["name", "xhh", "age", "1"]

//=> 加分组捕获
ary = str.split(/(=|&)/); //-> ["name", "=", "xhh", "&", "age", "=", "1"]
//=> 分组内容只匹配不捕获 在当前分组中加?: 
//=> 作用：加括号改变优先级...
ary = str.split(/(?:=|&)/); //-> ["name", "xhh", "age", "1"] 
```

##### replace
实现字符串中原有字符的替换
`str.replace(old, new)`

原理：
1. 当replace方法执行，第一项传递一个正则：
    - 正则不加g：把当前字符串中第一个和正则匹配的结果捕获到，替换成新的字符
    - 正则不加g：把当前字符串中所有和正则匹配的结果都分别捕获到，每一次捕获，都会把当前捕获的内容替换成新字符
2. 当replace方法执行，第二个参数传递的是一个函数（回调函数）
    - 首先用正则到字符串中进行查找匹配，匹配到一个符合规则的，就把传递的函数执行一次
    - 不仅执行这个函数，还把正则本次捕获的结果（和执行exec捕获的结果一样：数组、大正则匹配、小分组匹配）当作实参传递给这个函数（这样就可以在函数中获取这些值）

**单词首字母大写**

```javascript
let str = 'my name is xhh-tutu, i am 1 ye/nar old'
//=> \b 边界，单词左右两边和-两边都是边界
// str = str.replace(/\b[a-z]/g, function() {
//     return arguments[0].toUpperCase();
// })

str = str.replace(/(^| )[a-z]/g, function() {
    return arguments[0].toUpperCase();
})
```
